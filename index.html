<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refactored Draggable Cards</title>
    <style>
        /* Custom CSS for the draggable cards */
        body {
            font-family: "Inter", sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scroll during drag */
            background-color: #1a202c; /* Dark background color */
            position: relative; /* Needed for absolute positioning of cards */
            min-height: 100vh; /* Ensure body takes full viewport height */
            width: 100vw; /* Ensure body takes full viewport width */
        }
        
        .draggable-card { /* Renamed from .draggable-square */
            position: absolute;
            width: 120px; /* Equivalent to w-24 */
            height: 120px; /* Equivalent to h-24 */
            border-radius: 0.125rem; /* Equivalent to rounded-lg */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Equivalent to shadow-xl */
            cursor: grab; /* Equivalent to cursor-grab */
            display: flex; /* Equivalent to flex */
            align-items: center; /* Equivalent to items-center */
            justify-content: center; /* Equivalent to justify-center */
            color: white; /* Equivalent to text-white */
            font-size: 1.25rem; /* Equivalent to text-xl */
            font-weight: 700; /* Equivalent to font-bold */
            transition: box-shadow 0.15s ease-in-out, transform 0.15s ease-in-out;
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
            border-style: solid; /* Added for border color */
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
            overflow: hidden; /* Crucial for absolute positioning of image */
        }
        
        .draggable-card.dragging {
            cursor: grabbing;
            /* z-index is set to 1000 in JS during drag */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); /* Larger shadow */
            transform: scale(1.05); /* Slightly enlarge when dragging */
        }
        
        .card-content {
            position: relative; /* Establish stacking context */
            z-index: 2; /* Ensure it's above the image and overlay */
            display: flex;
            flex-direction: column;
            align-items: center; /* Keep this for horizontal centering of name/bottom-info */
            justify-content: space-between; /* Distribute space between elements */
            width: 100%;
            height: 100%;
            padding: 0 0.25rem 0.25rem 0.25rem; /* Removed top padding, kept side/bottom */
        }
        
        .card-image {
            position: absolute; /* Take out of flow */
            top: 0;
            left: 0;
            width: 100%; /* Fill parent */
            height: 100%; /* Fill parent */
            object-fit: cover; /* Cover the area, cropping if necessary */
            border-radius: 0.125rem; /* Match parent border-radius */
            z-index: 0; /* Background layer */
        }
        
        .card-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent; /* Make it transparent */
            z-index: 1; /* Above image, below content */
        }
        
        .card-name {
            font-size: 0.75rem; /* Smaller font for name (12px) */
            font-weight: bold;
            color: white;
            text-align: center;
            margin-bottom: 0; /* No explicit margin-bottom, flexbox handles spacing */
            flex-shrink: 0;
            /* z-index: 1; This is handled by parent .card-content z-index */
        }
        
        .card-cost {
            position: absolute;
            top: 0.125rem; /* Small padding from top */
            right: 0.125rem; /* Small padding from right */
            font-size: 0.7rem; /* Slightly smaller than name */
            font-weight: bold;
            color: white;
            background-color: #000; /* Semi-transparent black background */
            border-radius: 50%; /* Circular shape */
            width: 1rem; /* Fixed width for circle */
            height: 1rem; /* Fixed height for circle */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3; /* Above overlay and image, below content */
            border: 1px solid rgba(255, 255, 255, 0.5); /* White border for definition */
        }
        
        
        /* Container for trigger/ability row */
        .card-bottom-info {
            display: flex;
            align-items: center;
            justify-content: center; /* Center the trigger/ability block */
            width: 100%; /* Take full width */
            flex-wrap: wrap; /* Changed from nowrap to wrap */
            flex-shrink: 0;
            margin-top: auto; /* Pushes this block to the bottom in flex column */
        }
        
        .trigger {
            display: flex;
            min-height: 1rem; /* 1.35rem * 0.9 */
            text-align: center;
            align-items: center;
            font-family: monospace;
            font-weight: 900;
            margin-left: 0.05625rem; /* 1mm ~ 1px */
            font-size: 0.54rem; /* 0.6rem * 0.9 */
            line-height: 1.25;
            background-color: #aaa;
            border: 1px solid rgba(0, 0, 0);
            border-right: 0;
            border-radius: 0.225rem 0.225rem 0.225rem 0.225rem; /* 0.25rem * 0.9 */
            padding: 0; /* Reduced vertical padding */
            word-break: break-word; /* Ensure long words break */
            z-index: 4;
            color: black;
        }
        
        .triggerarrow {
            width: 0;
            height: 0;
            border-style: solid;
            flex-shrink: 0;
        }
        
        .triggerarrow {
            border-width: 0.39375rem 0.39375rem 0.39375rem 0.2rem; /* 0.625rem * 0.9, 0.4375rem * 0.9 */
            border-color: transparent transparent transparent #aaa;
            z-index: 2;
            margin-right: -0.05625rem; /* 0.0625rem * 0.9 */
        }
        
        .ability {
            display: flex;
            min-height: 1rem; /* 1.35rem * 0.9 */
            align-items: center;
            text-align: center;
            font-family: monospace;
            font-weight: 900;
            margin-left: -0.5rem; /* -1rem * 0.9 */
            padding: 0 0 0 .25rem; /* Reduced vertical padding */
            font-size: 0.54rem; /* 0.6rem * 0.9 */
            line-height: 1.25;
            background-color: rgba(238, 238, 238);
            border: 1px solid rgba(0, 0, 0);
            border-left: 0;
            border-radius: 0.225rem 0.225rem 0.225rem 0.225rem; /* 0.25rem * 0.9 */
            word-break: break-word; /* Ensure long words break */
            z-index: 0;
            color: black;
        }
        #menu-bar {
            position: absolute;
            /*background-color: black;*/
            width: 50%;
            margin: auto;
            /*height: 10%;*/
        }
        #menu {
            position: absolute;
            /*background-color: black;*/
            width: 20%;
            height: 100%;
            border-radius: 0px;
            text-align: center;
            font-family: serif;
            color: black;
            border-radius: 8px;          /* Rounded corners */
            padding: 10px;
            background-color: #5b5b5b;   /* Dark red */
            color: #ffebcd;              /* Light red text */
            height: 1em;
            margin: 5px;
            border: 2px solid #ffae17;   /* Light red border */
            background-color: #2c2311;   /* Dark red */
        }
        #menu:hover {
            background-color: #0004;
        }
        #hover-target {
            display: inline-block;
            padding: 10px;
            background-color: #0008;
            color: white;
            cursor: pointer;
        }
        .list {
            position: absolute;
            margin-top: 40px;
            border: 1px solid #ccc;
            display: none;
            z-index: 1000;
            max-height: 200px;
            overflow-y: auto;
            transform: translateX(34%);
            background: #fff5e5; /* light red */
        }
        
        #list div {
            padding: 8px 12px;
            cursor: pointer;
        }
        #list div:hover  {
            background-color: #f0f0f0;
        }
        #menu:hover + #list,
        #list:hover {
            display: block;
        }
        
    </style>
</head>
<body>
    <div id="menu-bar">
        <div id="menu">Tiles</div>
        <div id="list" class="list"></div>
        <!--<span id="menu3"><h2>Option 3</h2></span>-->
    </div>
    <script>
        // Global variables to manage the drag state
        let draggingCardElement = null; // Stores the HTML element currently being dragged
        let draggingCardData = null; // Stores the data object of the card being dragged
        let offsetX, offsetY; // Stores the offset from the mouse/touch position to the card's top-left corner
        let hoveredCardId = null; // Stores the ID of the card currently being hovered over (for desktop 'f' key)
        let draggedStack = []; // Stores the entire stack of cards being dragged together
        
        // Variables for long-press functionality (for mobile 'f' key equivalent)
        let longPressTimer = null;
        let longPressTargetId = null;
        
        // Variables for double-tap functionality
        let lastTapTime = 0;
        let lastTapTargetId = null;
        
        // Variables for single-tap / drag detection
        let startTime = 0; // Stores the timestamp when the current touch/click started
        let initialTouchX = 0; // Stores the X coordinate of the touchstart
        let initialTouchY = 0; // Stores the Y coordinate of the touchstart
        let initialTouchTargetId = null; // Stores the ID of the element that started the touch
        let isDragging = false; // True if a drag operation is active (movement detected)
        let isTapCandidate = false; // True if touchstart occurred and no significant movement yet
        
        // Constants for grid and card sizing
        const GRID_SIZE = 130; // The size of the grid cells for snapping (in pixels)
        const CARD_SIZE = 120; // Actual size of the card based on w-24 h-24 Tailwind classes (96px)
        const Z_OFFSET_DISPLAY = 10; // The pixel offset for display per z-level
        const LONG_PRESS_DURATION = 500; // Duration in milliseconds for a long press
        const DOUBLE_TAP_DURATION = 300; // Duration in milliseconds for a double tap
        const MOVEMENT_THRESHOLD_FOR_DRAG = 10; // Pixels moved to be considered a drag instead of a tap
        
        // Define hex color constants for consistency
        const COLOR_YELLOW_500 = '#F59E0B';
        const COLOR_RED_500 = '#EF4444';
        const COLOR_BLUE_500 = '#3B82F6';
        const COLOR_GREEN_500 = '#22C55E';
        const COLOR_CYAN_500 = '#06B6D4';
        const COLOR_PURPLE_500 = '#A855F7';
        const COLOR_GRAY_700 = '#4B5563';
        const COLOR_GRAY_500 = '#6B7280';
        
        // Variable to store the CSV text
        let csvTextData = "";
        const csvUrl = "https://arborius.online/cards.csv";
        const cardTemplates = {};
        const cardnames = [];
        /**
        * Fetches CSV data from the given URL and stores it in csvTextData.
        */
        async function fetchCsvData() {
            try {
                const response = await fetch(csvUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                csvTextData = await response.text(); // Store raw CSV text
                // Parse CSV data into cardTemplates Map
                if (csvTextData) {
                    const rows = csvTextData.split('\n').filter(row => row.trim() !== '');
                    const dataRows = rows.slice(1); // Skip header row

                    dataRows.forEach(row => {
                        const name = row.split(",")[0];
                        cardTemplates[name] = row;
                        cardnames.push(name);
                    });
                    console.log("Card templates populated:", cardTemplates.size, "cards");
                }

            } catch (error) {
                console.error("Error fetching or parsing CSV data:", error);
                // Optionally display an error message to the user
            }
            // Red dropdown
            const tiledropdown = document.getElementById('list');
            cardnames.forEach(text => {
                const item = document.createElement('div');
                item.textContent = text;
                item.onclick = () => {
                    const newcard = processCsvRow(cardTemplates[text]);
                    cardsData.push(newcard);
                    console.log(newcard);
                    ws.send(JSON.stringify({ type: 'createcard', data: newcard.stringify() }));
                    renderCards();
                };
                tiledropdown.appendChild(item);
            });
        }
        
        var cardid = 0;
        /**
        * Factory function to create a new card object.
        * This centralizes card creation and ensures consistent metadata.
        * @param {string} typeId - Identifier for the card type (e.g., 'goblin', 'fireball').
        * @param {string} name - Display name of the card.
        * @param {number} cost - Mana/resource cost of the card.
        * @param {string} borderColor - Hex color string for border (e.g., '#F59E0B').
        * @param {string} imgUrl - URL for the card's image.
        * @param {string} trigger - Description of when the card's ability triggers.
        * @param {string} ability - Description of the card's ability.
        * @param {number} gridX - Initial X coordinate on the grid (integer column).
        * @param {number} gridY - Initial Y coordinate on the grid (integer row).
        * @param {number} z - Initial Z coordinate (for stacking).
        * @param {string} color - Hex color string for background (e.g., '#EF4444').
        * @param {number} [rotation=0] - Initial rotation in degrees.
        * @param {boolean} [isGrayedOut=false] - Initial grayed out state.
        * @returns {object} The new card object.
        */
        function makeCard(typeId, name, cost, borderColor, imgUrl, trigger, ability, gridX, gridY, z, color, rotation = 0, isGrayedOut = false) {
            const card = {
                uuid: cardid++, // Unique ID for this specific card instance
                typeId: typeId, // ID for the card type
                name: name,
                cost: cost,
                borderColor: borderColor,
                imgUrl: imgUrl,
                trigger: trigger,
                ability: ability,
                gridX: gridX, // Stored as grid-level integer coordinate
                gridY: gridY, // Stored as grid-level integer coordinate
                z: z,
                color: color, // Original background color hex
                isGrayedOut: isGrayedOut, // New property to track grayed-out state
                rotation: rotation, // New property for rotation in degrees (0, 90, 180, 270)
                // Temporary pixel coordinates used only during drag for smooth movement
                // These are not part of the 'permanent' data structure
                tempPixelX: 0,
                tempPixelY: 0,
                /**
                * Returns a JSON string representation of the card's properties.
                * Excludes temporary display properties.
                * @returns {string} JSON string of the card.
                */
                stringify: function() {
                    const serializableCard = { ...this }; // Create a shallow copy
                    delete serializableCard.tempPixelX; // Remove temporary properties
                    delete serializableCard.tempPixelY;
                    delete serializableCard.stringify; // Remove the function itself
                    return JSON.stringify(serializableCard);
                }
            };
            return card;
        }
        
        /**
        * Processes a single CSV row and creates a new card object.
        * Assumes the CSV row has the format: name,cost,trigger,ability,imgurl
        * @param {string} csvRow - A single row string from the CSV.
        * @returns {object|null} A new card object or null if parsing fails.
        */
        function processCsvRow(csvRow) {
            const parts = csvRow.split(',');
            // The CSV header is: name,cost,trigger,ability,imgurl,fancyname,fancylore,fancyimage,,,
            // We need the first 5 parts: name, cost, trigger, ability, imgurl
            if (parts.length < 5) { // Check if there are enough parts
                console.error("Invalid CSV row format. Expected at least 5 parts, got:", parts.length, csvRow);
                return null;
            }
            
            const name = parts[0];
            const costStr = parts[1];
            const trigger = parts[2];
            const ability = parts[3];
            const imgUrl = parts[4];
            
            const cost = parseInt(costStr, 10);
            
            if (isNaN(cost)) {
                console.error("Invalid cost in CSV row:", costStr, csvRow);
                return null;
            }
            
            // Default values for parameters not in CSV
            const typeId = 'csv-card'; // Generic typeId for cards loaded from CSV
            const borderColor = COLOR_PURPLE_500; // Default border color
            const gridX = 0; // Default grid X position
            const gridY = 0; // Default grid Y position
            const z = 0; // Default Z position
            const color = COLOR_GRAY_700; // Default background color
            
            return makeCard(typeId, name, cost, borderColor, imgUrl, trigger, ability, gridX, gridY, z, color);
        }
        
        // Array to store card data objects
        // Initialize as an empty array, will be populated from CSV
        let cardsData = [];
        
        /**
        * Creates the HTML div element for a given card data object.
        * @param {object} cardData - The data object for the card.
        * @returns {HTMLElement} The newly created div element.
        */
        function makeCardHtml(cardData) {
            const div = document.createElement('div');
            div.id = cardData.uuid; // Use UUID as the element ID
            div.className = `draggable-card`; // Removed Tailwind classes
            
            // Apply border color and width
            div.style.borderWidth = '2px'; // Example border width
            div.style.backgroundColor = cardData.isGrayedOut ? COLOR_GRAY_500 : cardData.borderColor; // Set background color
            
            // Add image
            const img = document.createElement('img');
            img.src = "https://arborius.online/card/"+cardData.imgUrl;
            img.alt = cardData.name;
            img.className = 'card-image';
            img.ondragstart = "return false;"; // Prevent image dragging
            div.appendChild(img);
            
            // Add transparent overlay
            const overlayDiv = document.createElement('div');
            overlayDiv.className = 'card-overlay';
            div.appendChild(overlayDiv);
            
            // Add cost element
            const costSpan = document.createElement('span');
            costSpan.className = 'card-cost';
            costSpan.textContent = cardData.cost;
            div.appendChild(costSpan);
            
            // Create content container
            const contentDiv = document.createElement('div');
            contentDiv.className = 'card-content';
            
            // Add name (above image)
            const nameSpan = document.createElement('span');
            nameSpan.className = 'card-name';
            nameSpan.textContent = cardData.name;
            contentDiv.appendChild(nameSpan);
            
            // Create container for trigger, arrows, and ability
            const bottomInfoDiv = document.createElement('div');
            bottomInfoDiv.className = 'card-bottom-info';
            
            // Add trigger text
            const triggerSpan = document.createElement('span');
            triggerSpan.className = 'trigger'; // Use new class
            triggerSpan.textContent = cardData.trigger;
            bottomInfoDiv.appendChild(triggerSpan);
            
            // Add trigger arrow
            const triggerArrowDiv = document.createElement('div');
            triggerArrowDiv.className = 'triggerarrow'; // Use new class
            bottomInfoDiv.appendChild(triggerArrowDiv);
            
            // Add ability text
            const abilitySpan = document.createElement('span');
            abilitySpan.className = 'ability'; // Use new class
            abilitySpan.textContent = cardData.ability;
            bottomInfoDiv.appendChild(abilitySpan);
            
            contentDiv.appendChild(bottomInfoDiv);
            div.appendChild(contentDiv);
            return div;
        }
        
        /**
        * Updates the display position, z-index, color, and rotation of a card's HTML element
        * based on its data object's grid coordinates, z-level, grayed-out state, and rotation.
        * @param {HTMLElement} cardElement - The HTML element of the card.
        * @param {object} cardData - The data object for the card.
        */
        function displayCard(cardElement, cardData) {
            // Calculate pixel position from grid coordinates
            const pixelX = cardData.gridX * GRID_SIZE;
            const pixelY = cardData.gridY * GRID_SIZE;
            
            // Apply z-offset for visual depth
            const displayX = pixelX - (cardData.z * Z_OFFSET_DISPLAY);
            const displayY = pixelY - (cardData.z * Z_OFFSET_DISPLAY);
            
            cardElement.style.left = `${displayX}px`;
            cardElement.style.top = `${displayY}px`;
            cardElement.style.zIndex = cardData.z; // Set z-index based on z property
            cardElement.style.transform = `rotate(${cardData.rotation}deg)`; // Apply rotation
            
            // Set background color based on isGrayedOut status
            cardElement.style.backgroundColor = cardData.isGrayedOut ? COLOR_GRAY_500 : cardData.color;
            // cardElement.style.borderColor = cardData.isGrayedOut ? COLOR_GRAY_500 : cardData.borderColor;
        }
        
        /**
        * Renders all cards based on the cardsData array.
        * This function is called on load and after any data updates.
        */
        function renderCards() { // Renamed from renderSquares
            const body = document.body;
            // Clear existing cards to re-render
            document.querySelectorAll('.draggable-card').forEach(el => el.remove()); // Updated class selector
            
            // Sort cards by z-index to ensure correct rendering order
            // Elements with lower z-index should be appended first to appear "underneath"
            const sortedCards = [...cardsData].sort((a, b) => a.z - b.z); // Updated array name
            
            sortedCards.forEach(card => {
                const div = makeCardHtml(card); // Use the new makeCardHtml function
                displayCard(div, card); // Use the new displayCard function to set initial position and color
                
                // Attach event listeners directly to the created element
                div.addEventListener('mousedown', startDrag);
                div.addEventListener('touchstart', startDrag, { passive: false });
                
                // Add mouseover/mouseout listeners for hover tracking
                div.addEventListener('mouseover', () => { hoveredCardId = card.uuid; }); // Use uuid for hovered ID
                div.addEventListener('mouseout', () => { hoveredCardId = null; });
                
                body.appendChild(div);
            });
        }
        
        /**
        * Handles the start of a drag operation (mousedown or touchstart).
        * @param {MouseEvent|TouchEvent} e - The event object.
        */
        function startDrag(e) {
            // Ensure the target is a draggable card or a child of a draggable card (like the overlay)
            const targetCard = e.target.closest('.draggable-card');
            if (!targetCard) return;
            
            draggingCardElement = targetCard;
            // Find the corresponding data object using UUID
            draggingCardData = cardsData.find(c => c.uuid == draggingCardElement.id); // Use == for comparison as uuid is string
            
            if (!draggingCardData) return; // Should not happen if logic is correct
            
            // Record start time and initial touch/mouse position
            startTime = new Date().getTime();
            const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
            initialTouchX = clientX;
            initialTouchY = clientY;
            initialTouchTargetId = draggingCardElement.id;
            
            // Clear any existing long press timer if a new interaction starts
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
                longPressTargetId = null;
            }
            
            // --- Touch-specific logic (double-tap, long-press, tap candidate) ---
            if (e.type === 'touchstart') {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTapTime;
                
                // 1. Double-tap check
                if (lastTapTargetId == draggingCardElement.id && tapLength < DOUBLE_TAP_DURATION) { // Use ==
                    toggleCardGrayState(draggingCardElement.id);
                    lastTapTime = 0; // Reset for next tap
                    lastTapTargetId = null;
                    e.preventDefault(); // Prevent default browser behavior (like scrolling)
                    return; // Double-tap handled, exit startDrag
                } else {
                    lastTapTime = currentTime;
                    lastTapTargetId = draggingCardElement.id;
                }
                
                // 2. Long-press setup (if not a double-tap)
                longPressTargetId = draggingCardElement.id;
                longPressTimer = setTimeout(() => {
                    // If this timer fires, it means a long press occurred without significant movement
                    if (longPressTargetId == draggingCardElement.id && !isDragging) { // Use ==
                        toggleCardGrayState(longPressTargetId);
                    }
                    longPressTimer = null;
                    longPressTargetId = null;
                    isTapCandidate = false; // Long press consumed the tap candidate
                }, LONG_PRESS_DURATION);
                
                isTapCandidate = true; // Mark as potential tap for single-tap rotation
            } else { // It's a mousedown event
            isTapCandidate = false; // No tap candidate for mouse events (they are drags or clicks)
        }
        
        // --- Drag initiation preparation (applies to both mouse and touch, unless double-tap handled) ---
        isDragging = false; // Assume not dragging initially, will be set in `drag` if movement occurs
        
        draggingCardElement.classList.add('dragging');
        draggingCardElement.style.zIndex = 1000;
        
        offsetX = clientX - draggingCardElement.offsetLeft;
        offsetY = clientY - draggingCardElement.offsetTop;
        
        draggingCardData.tempPixelX = draggingCardElement.offsetLeft + (draggingCardData.z * Z_OFFSET_DISPLAY);
        draggingCardData.tempPixelY = draggingCardElement.offsetTop + (draggingCardData.z * Z_OFFSET_DISPLAY);
        
        draggedStack = [];
        draggedStack.push({
            cardData: draggingCardData,
            element: draggingCardElement,
            initialPixelX: draggingCardData.tempPixelX, // Use tempPixelX/Y as initial raw pixel
            initialPixelY: draggingCardData.tempPixelY,
            initialZ: draggingCardData.z // Store original Z
        });
        
        // Find other cards in the same grid space with greater Z
        const currentGridX = draggingCardData.gridX;
        const currentGridY = draggingCardData.gridY;
        
        cardsData.forEach(c => { // Updated array name
            if (c.uuid == draggingCardData.uuid) return; // Use == for comparison
            
            if (c.gridX === currentGridX && c.gridY === currentGridY && c.z > draggingCardData.z) {
                const stackedElement = document.getElementById(c.uuid); // Use uuid for element ID
                if (stackedElement) {
                    // Set tempPixelX/Y for stacked cards based on their current displayed position
                    c.tempPixelX = stackedElement.offsetLeft + (c.z * Z_OFFSET_DISPLAY);
                    c.tempPixelY = stackedElement.offsetTop + (c.z * Z_OFFSET_DISPLAY);
                    
                    draggedStack.push({
                        cardData: c,
                        element: stackedElement,
                        initialPixelX: c.tempPixelX,
                        initialPixelY: c.tempPixelY,
                        initialZ: c.z // Store original Z
                    });
                    stackedElement.classList.add('dragging'); // Also add dragging class to stacked elements
                    stackedElement.style.zIndex = 1000; // Bring to front during drag
                }
            }
        });
        
        if (e.type === 'touchstart') {
            e.preventDefault();
        }
    }
    
    /**
    * Handles the drag operation (mousemove or touchmove).
    * Updates the position of the dragging card.
    * @param {MouseEvent|TouchEvent} e - The event object.
    */
    function drag(e) {
        // Clear long press timer if movement occurs
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
            longPressTargetId = null;
        }
        
        // If movement is detected, it's a drag, not a tap
        if (isTapCandidate) {
            const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
            const distance = Math.sqrt(
            Math.pow(clientX - initialTouchX, 2) +
            Math.pow(clientY - initialTouchY, 2)
            );
            if (distance > MOVEMENT_THRESHOLD_FOR_DRAG) {
                isTapCandidate = false; // It's a drag, not a tap
                isDragging = true; // Mark as dragging
            }
        }
        
        // Only proceed if a card is currently being dragged or is a potential drag
        if (!draggingCardElement || !draggingCardData) return;
        
        // Determine clientX and clientY based on event type
        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
        
        // Calculate new raw pixel position for the main dragged card
        let newMainPixelX = clientX - offsetX;
        let newMainPixelY = clientY - offsetY;
        
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        // Clamp main card's position
        newMainPixelX = Math.max(0, Math.min(newMainPixelX, windowWidth - CARD_SIZE));
        newMainPixelY = Math.max(0, Math.min(newMainPixelY, windowHeight - CARD_SIZE));
        
        // Update main card's temporary pixel position
        draggingCardData.tempPixelX = newMainPixelX;
        draggingCardData.tempPixelY = newMainPixelY;
        
        // Apply new position to main card's DOM element
        draggingCardElement.style.left = `${newMainPixelX - (draggingCardData.z * Z_OFFSET_DISPLAY)}px`;
        draggingCardElement.style.top = `${newMainPixelY - (draggingCardData.z * Z_OFFSET_DISPLAY)}px`;
        
        // Move stacked cards relative to the main dragged card
        const mainCardInitialPixelX = draggedStack[0].initialPixelX;
        const mainCardInitialPixelY = draggedStack[0].initialPixelY;
        
        const deltaX = newMainPixelX - mainCardInitialPixelX;
        const deltaY = newMainPixelY - mainCardInitialPixelY;
        
        for (let i = 1; i < draggedStack.length; i++) { // Start from 1 to skip the main card
            const stackedItem = draggedStack[i];
            const stackedCardData = stackedItem.cardData;
            const stackedElement = stackedItem.element;
            
            let newStackedPixelX = stackedItem.initialPixelX + deltaX;
            let newStackedPixelY = stackedItem.initialPixelY + deltaY;
            
            // Clamp stacked card's position (optional, but good for consistency)
            newStackedPixelX = Math.max(0, Math.min(newStackedPixelX, windowWidth - CARD_SIZE));
            newStackedPixelY = Math.max(0, Math.min(newStackedPixelY, windowHeight - CARD_SIZE));
            
            stackedCardData.tempPixelX = newStackedPixelX;
            stackedCardData.tempPixelY = newStackedPixelY;
            
            stackedElement.style.left = `${newStackedPixelX - (stackedCardData.z * Z_OFFSET_DISPLAY)}px`;
            stackedElement.style.top = `${newStackedPixelY - (stackedCardData.z * Z_OFFSET_DISPLAY)}px`;
        }
        
        if (e.type === 'touchmove') {
            e.preventDefault();
        }
    }
    
    /**
    * Resets all global state variables related to drag/tap interactions.
    */
    function resetInteractionState() {
        draggingCardElement = null;
        draggingCardData = null;
        offsetX = 0;
        offsetY = 0;
        longPressTimer = null;
        longPressTargetId = null;
        lastTapTime = 0;
        lastTapTargetId = null;
        startTime = 0;
        initialTouchX = 0;
        initialTouchY = 0;
        initialTouchTargetId = null;
        isDragging = false;
        isTapCandidate = false;
        draggedStack = [];
    }
    
    /**
    * Handles the end of a drag operation (mouseup or touchend).
    * Resets the drag state and snaps the card to the grid, updating z-index.
    * @param {MouseEvent|TouchEvent} e - The event object.
    */
    function endDrag(e) {
        // Clear any active long press timer if the interaction ends
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
            longPressTargetId = null;
        }
        
        // If no dragging element was set, it means the interaction was already handled
        // (e.g., a double-tap in startDrag) or it was a non-interactive click.
        if (!draggingCardElement || !draggingCardData) {
            resetInteractionState();
            return;
        }
        
        // Get current clientX/Y for final position calculation
        const currentClientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        const currentClientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
        
        const distanceMoved = Math.sqrt(
        Math.pow(currentClientX - initialTouchX, 2) +
        Math.pow(currentClientY - initialTouchY, 2)
        );
        const tapDuration = new Date().getTime() - startTime;
        
        // --- Mobile Tap Rotation Logic ---
        // This block specifically handles single taps for rotation on touch devices.
        // It must be a touchend, a tap candidate, not a drag, and within tap duration/movement thresholds.
        if (e.type === 'touchend' && isTapCandidate && !isDragging && tapDuration < DOUBLE_TAP_DURATION && distanceMoved < MOVEMENT_THRESHOLD_FOR_DRAG) {
            // Confirm it's the same element that initiated the tap
            if (initialTouchTargetId == draggingCardElement.id) { // Use ==
                const rect = draggingCardElement.getBoundingClientRect();
                const tapX = currentClientX - rect.left; // X coordinate relative to the card
                const cardWidth = rect.width;
                
                if (tapX > cardWidth / 2) {
                    rotateCardCW(draggingCardElement.id); // Right half
                } else {
                    rotateCardCCW(draggingCardElement.id); // Left half
                }
            }
            // Reset all interaction state, as the tap was handled
            resetInteractionState();
            return; // Tap handled, exit endDrag
        }
        
        // --- General Drag End Logic (applies to both mouse drags and touch drags) ---
        // This block executes if a drag was genuinely initiated (isDragging is true)
        // OR if it was a mouseup (where isTapCandidate is always false, and we want to snap even for clicks).
        // The `isDragging` flag primarily differentiates touch taps from touch drags.
        // For mouse, any mousedown followed by mouseup should trigger this.
        
        // Calculate the snapped grid position for the main dragged card
        let snappedGridX = Math.round(draggingCardData.tempPixelX / GRID_SIZE);
        let snappedGridY = Math.round(draggingCardData.tempPixelY / GRID_SIZE);
        
        // Convert snapped grid coordinates back to pixel coordinates for boundary checks
        let snappedPixelX = snappedGridX * GRID_SIZE;
        let snappedPixelY = snappedGridY * GRID_SIZE;
        
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        snappedPixelX = Math.max(0, Math.min(snappedPixelX, windowWidth - CARD_SIZE));
        snappedPixelY = Math.max(0, Math.min(snappedPixelY, windowHeight - CARD_SIZE));
        
        // Update main card's grid position
        draggingCardData.gridX = Math.round(snappedPixelX / GRID_SIZE);
        draggingCardData.gridY = Math.round(snappedPixelY / GRID_SIZE);
        
        // Determine new Z for the main dragged card
        let maxZAtNewLocation = -1;
        cardsData.forEach(c => { // Updated array name
            // Exclude all cards that were part of the *dragged stack* from this Z calculation
            // because their Z will be adjusted relatively.
            const isPartOfDraggedStack = draggedStack.some(item => item.cardData.uuid == c.uuid); // Use == for comparison
            if (isPartOfDraggedStack) {
                return;
            }
            
            if (c.gridX === draggingCardData.gridX && c.gridY === draggingCardData.gridY) {
                if (c.z > maxZAtNewLocation) {
                    maxZAtNewLocation = c.z;
                }
            }
        });
        
        const originalMainZ = draggedStack[0].initialZ;
        const newMainZ = maxZAtNewLocation + 1;
        const zDifference = newMainZ - originalMainZ;
        
        draggingCardData.z = newMainZ;
        
        // Now update positions and Z for all cards in the dragged stack
        draggedStack.forEach(stackedItem => {
            const stackedCardData = stackedItem.cardData;
            
            // All cards in the stack snap to the same grid position as the main card
            stackedCardData.gridX = draggingCardData.gridX;
            stackedCardData.gridY = draggingCardData.gridY;
            
            // Apply the same Z difference to maintain relative stacking order
            stackedCardData.z = stackedItem.initialZ + zDifference;
            
            // Send update for each card in the dragged stack
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'updatecard', data: stackedCardData.stringify() }));
            }
        });
        
        renderCards(); // Re-render to apply all final positions and Z-indices
        
        // Reset all interaction state
        resetInteractionState();
    }
    
    /**
    * Toggles the 'isGrayedOut' state of a card and re-renders the cards.
    * @param {string} cardUuid - The UUID of the card to toggle.
    */
    function toggleCardGrayState(cardUuid) {
        const targetCard = cardsData.find(c => c.uuid == cardUuid); // Use == for lookup
        if (targetCard) {
            targetCard.isGrayedOut = !targetCard.isGrayedOut; // Toggle the state
            renderCards(); // Re-render to apply the color change
            
            // Send updatecard message
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'updatecard', data: targetCard.stringify() }));
            }
        }
    }
    
    /**
    * Rotates a card clockwise by 90 degrees and re-renders.
    * @param {string} cardUuid - The UUID of the card to rotate.
    */
    function rotateCardCW(cardUuid) {
        const targetCard = cardsData.find(c => c.uuid == cardUuid); // Use == for lookup
        if (targetCard) {
            targetCard.rotation = (targetCard.rotation + 90) % 360; // Rotate by 90 degrees CW
            renderCards();
            
            // Send updatecard message
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'updatecard', data: targetCard.stringify() }));
            }
        }
    }
    
    /**
    * Rotates a card counter-clockwise by 90 degrees and re-renders.
    * @param {string} cardUuid - The UUID of the card to rotate.
    */
    function rotateCardCCW(cardUuid) {
        const targetCard = cardsData.find(c => c.uuid == cardUuid); // Use == for lookup
        if (targetCard) {
            targetCard.rotation = (targetCard.rotation - 90 + 360) % 360; // Rotate by 90 degrees CCW, handle negative results
            renderCards();
            
            // Send updatecard message
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'updatecard', data: targetCard.stringify() }));
            }
        }
    }
    
    /**
    * Handles key press events, specifically for toggling card color and rotation.
    * @param {KeyboardEvent} e - The keyboard event object.
    */
    function handleKeyPress(e) {
        if (hoveredCardId !== null) { // Use hoveredCardId
            const targetCard = cardsData.find(c => c.uuid == hoveredCardId); // Use ==
            if (!targetCard) return;
            
            if (e.key === 'f') {
                toggleCardGrayState(hoveredCardId); // Toggle gray state
            } else if (e.key === 'q') {
                rotateCardCCW(hoveredCardId); // Rotate CCW
            } else if (e.key === 'e') {
                rotateCardCW(hoveredCardId); // Rotate CW
            } else if (e.key === 'r') {
                // Toggle border color between blue and red
                if (targetCard.borderColor === COLOR_BLUE_500) {
                    targetCard.borderColor = COLOR_RED_500;
                    targetCard.color = COLOR_RED_500;
                } else {
                    targetCard.borderColor = COLOR_BLUE_500;
                    targetCard.color = COLOR_BLUE_500;
                }
                renderCards(); // Re-render to apply the color change
                
                // Send updatecard message
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'updatecard', data: targetCard.stringify() }));
                }
            }
        }
    }
    
    // --- WebSocket Client Functionality ---
    let ws = null; // Declare ws globally so it can be accessed by handleWebSocketMessage
    
    /**
    * Parses a card JSON string and re-attaches the stringify method.
    * @param {string} cardJson - The JSON string representation of a card.
    * @returns {object} The parsed card object with the stringify method.
    */
    function parseCard(cardJson) {
        const card = JSON.parse(cardJson);
        // Re-add the stringify method to the reconstructed card object
        card.stringify = function() {
            const serializableCard = { ...this };
            delete serializableCard.tempPixelX;
            delete serializableCard.tempPixelY;
            delete serializableCard.stringify;
            return JSON.stringify(serializableCard);
        };
        return card;
    }
    
    /**
    * Handles incoming WebSocket messages, parsing them and directing to appropriate logic.
    * @param {MessageEvent} event - The WebSocket message event.
    */
    function handleWebSocketMessage(event) {
        console.log('WebSocket message received:', event.data);
        try {
            const message = JSON.parse(event.data);
            switch (message.type) {
                case 'sync':
                console.log('Received sync message:', message);
                // Respond with a gamestate message
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'gamestate', count: cardid, data: JSON.stringify(cardsData.map(card => card.stringify()))}));
                }
                break;
                case 'gamestate':
                console.log('Received gamestate message:', message);
                // Clear all existing card elements from the DOM
                document.querySelectorAll('.draggable-card').forEach(el => el.remove());
                
                // Update cardsData to match the received cardsData
                cardsData = JSON.parse(message.data).map(parseCard); // Use the new parseCard function
                cardid = message.count;
                // Re-render all the elements with renderCards
                renderCards();
                break;
                case 'updatecard':
                console.log('Received updatecard message:', message);
                const updatedCardData = parseCard(message.data); // Use the new parseCard function
                const targetCardIndex = cardsData.findIndex(c => c.uuid == updatedCardData.uuid); // Use ==
                
                if (targetCardIndex !== -1) {
                    // Update the existing card's properties
                    cardsData[targetCardIndex] = updatedCardData;
                    renderCards(); // Re-render to reflect the changes
                } else {
                    console.warn('Received update for unknown card:', updatedCardData.uuid);
                }
                break;
                case 'createcard':
                console.log('Received createcard message:', message);
                const newCardProps = parseCard(message.data); // Use parseCard for incoming data
                // Create a new card object using the makeCard factory function
                const newCard = makeCard(
                newCardProps.typeId,
                newCardProps.name,
                newCardProps.cost,
                newCardProps.borderColor,
                newCardProps.imgUrl,
                newCardProps.trigger,
                newCardProps.ability,
                newCardProps.gridX,
                newCardProps.gridY,
                newCardProps.z,
                newCardProps.color,
                newCardProps.rotation, // Pass rotation
                newCardProps.isGrayedOut // Pass isGrayedOut
                );
                cardsData.push(newCard); // Add the new card to the array
                renderCards(); // Re-render to display the new card
                break;
                case 'destroycard':
                console.log('Received destroycard message:', message);
                const destroyedCardUuid = message.data; // Assuming message.data is just the UUID string
                const indexToRemove = cardsData.findIndex(c => c.uuid == destroyedCardUuid); // Use ==
                
                if (indexToRemove !== -1) {
                    cardsData.splice(indexToRemove, 1); // Remove the card from the array
                    renderCards(); // Re-render to update the display
                } else {
                    console.warn('Received destroy for unknown card UUID:', destroyedCardUuid);
                }
                break;
                default:
                console.warn('Received unknown message type:', message.type, message);
            }
        } catch (error) {
            console.error('Error parsing WebSocket message:', error, event.data);
        }
    }
    // --- End WebSocket Client Functionality ---
    
    
    // Initialize the application when the window loads
    window.onload = async function() {
        await fetchCsvData(); // Fetch CSV data before rendering cards
        
        // Clear initial placeholder cards
        // cardsData = [];
        
        // // Process CSV data and populate cardsData
        // if (csvTextData) {
        //     const rows = csvTextData.split('\n').filter(row => row.trim() !== '');
        //     // Assuming the first row is a header and should be skipped
        //     const dataRows = rows.slice(1); // Skip header row
            
        //     let currentX = 0;
        //     let currentY = 0;
        //     const cardsPerRow = 5; // Adjust as needed for layout
            
        //     dataRows.forEach((row, index) => {
        //         const card = processCsvRow(row);
        //         if (card) {
        //             // Assign grid positions to new cards from CSV
        //             card.gridX = currentX;
        //             card.gridY = currentY+1;
        //             card.z = 0; // Default Z for new cards
                    
        //             cardsData.push(card);
                    
        //             currentX++;
        //             if (currentX >= cardsPerRow) {
        //                 currentX = 0;
        //                 currentY++;
        //             }
        //         }
        //     });
        // }
        
        
        renderCards(); // Render cards on page load
        
        // --- Simple WebSocket Client Initialization ---
        const websocketUrl = 'wss://arborius.online'; // Replace with your WebSocket server URL
        ws = new WebSocket(websocketUrl); // Assign to global ws variable
        
        ws.onopen = (event) => {
            console.log('WebSocket connection opened:', event);
            ws.send(JSON.stringify({ type: "sync" })); // Send a single message
        };
        
        ws.onmessage = handleWebSocketMessage; // Assign the new handler function
        
        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
        
        ws.onclose = (event) => {
            console.log('WebSocket connection closed:', event);
        };
        // --- End WebSocket Client Initialization ---
        
        
        // Attach global event listeners to the window for dragging and ending drag
        // This ensures dragging continues even if the pointer moves off the card
        window.addEventListener('mousemove', drag);
        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchmove', drag, { passive: false }); // passive: false to allow preventDefault
        window.addEventListener('touchend', endDrag);
        window.addEventListener('touchcancel', endDrag); // Also handle touchcancel to clear timers
        
        // Attach keydown event listener for toggling color and rotation
        window.addEventListener('keydown', handleKeyPress);
    };
</script>
</body>
</html>
